# 三次握手 (发起TCP连接)
* 客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序列号设定为随机数 A，称为ISN。
* 服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。
* 最后，客户端再发送一个ACK，确认码为B+1。当服务端收到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。

* ### 初始序号 ISN
当新连接建立的时候，握手报文的第一个字节数据的序号称为 ISN(Initial Sequence Number)，即初始序号。
ISN的意义是 可以让接收方生成一个合法的接收窗口。
ISN是一个32位动态随机数，一是为了避免数据乱序(使用相同的序号会导致数据乱序)，二是避免报文被伪造。

* ### TCP包的类型 (SYN, FIN, ACK, PSH, RST, URG)
在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG。
对于我们日常的分析有用的就是前面的五个字段。
SYN: 同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。
FIN: finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。
ACK: 确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。
PSH: push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。
RST: 重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。
URG: 紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。

* ### 为什么需要进行三次握手？
    + 为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手
    + 为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。
总结就是，服务端要确认客户端能收到自己的信息才会建立连接，所以需要第三次握手。
如果第三次握手服务端没有收到，则不会建立连接。

* ### 如果第三次握手的ACK丢失怎么办？
如果第三次握手的ACK在网络中丢失，那么Server端该TCP连接的状态为SYN_RECV，并且依次等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。
Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5。
如果重发指定次数后，仍然未收到ACK应答，那么一段时间后，Server自动关闭这个连接。
但是Client认为这个连接已经建立，如果Client端向Server写数据，Server端将以RST包(用于强制关闭tcp连接)响应，方能感知到Server的错误。

---
# 四次挥手 (关闭TCP连接)
注意: 中断连接端可以是客户端，也可以是服务器端. 下面仅以客户端断开连接举例, 反之亦然.
    1. 客户端发送一个数据分段, 其中的 FIN 标记设置为1（最后一个发送的数据分段中附带FIN标志位）。 客户端进入 FIN-WAIT 状态. 该状态下客户端只接收数据, 不再发送数据.
    2. 服务器接收到带有 FIN = 1 的数据分段, 发送带有 ACK = 1 的剩余数据分段, 确认收到客户端发来的 FIN 信息（在某个返回的数据分段中附带ACK标志位，只是确认收到FIN消息）.
    3. 服务器等到所有数据传输结束, 向客户端发送一个带有 FIN = 1 的数据分段（最后一个返回的数据分段中附带FIN标志位）, 并进入 CLOSE-WAIT 状态, 等待客户端发来带有 ACK = 1 的确认报文.
    4. 客户端收到服务器发来带有 FIN = 1 的报文, 返回 ACK = 1 的报文确认, 为了防止服务器端未收到需要重发, 进入 TIME-WAIT 状态. 服务器接收到报文后关闭连接. 客户端等待 2MSL 后未收到回复, 则认为服务器成功关闭, 客户端关闭连接.

* ### 关闭连接和建立连接时的区别
相较于tcp的建立，tcp关闭的时候需要释放两端的资源(发送未完成的数据)，因此多了一个对端的FIN的状态。

* ### 关闭TCP连接时一定要四次挥手吗？第二次的ACK和第三次的FIN能否合并？
不一定要四次挥手。
第二次和第三次完全可以合并，即服务端在收到客户端的FIN报文后，在最后一个数据分段中同时发送 ACK和FIN。
这种方式叫做"延迟确认优化"，在RFC793 3.5节。

* ### 为什么会设计第二次挥手？
我的想法：
服务端在收到客户端的FIN报文时，可能仍有一批数据没有传完，无法立即关闭SOCKET，所以只能先回复一个ACK报文。

此时，如果服务端不立即回复一个ACK报文，客户端将无法得知服务端有没有收到自己的FIN报文。于是，客户端就需要定时重发FIN报文。
服务端先发一个ACK报文，客户端就会进入 FIN-WAIT-2状态 (此前是FIN-WAIT-1状态)，等待接收服务端的FIN报文即可。

* ### 关闭连接至少需要几次挥手？
3次。服务端需要确认客户端收到了自己发送的最后一个数据分段(即带有FIN标记的数据分段)，因此至少需要三次挥手。

* ### 服务端运行一段时间后，套接字出现了大量的Close_Wait状态，最有可能是什么原因导致的？
收到了客户端发送的断开请求(FIN报文)，但是服务器还有未发完的数据。

* ### 为什么基于TCP的程序往往都有个应用层的心跳检测机制？
TCP建立链接之后，只是在两端的内核里面维持tcp信息，实际上并没有一个物理的连接的通路，对端这个时候挂了，谁也不知道。

* ### TCP四次分手中，主动关闭方最后为什么要等待2MSL之后才关闭连接？
MSL是最大报文生存周期。
假如是客户端主动发起关闭连接，第四次挥手中客户端发送了ACK报文，但是不确定服务端是否有收到。
如果服务端没有收到，则会再次重复第三次挥手(发送FIN报文)，客户端再收到FIN报文，就再重发ACK报文。
如果客户端在2MSL时间内，没有再次收到服务端发来的FIN报文，那么大概率服务端已经收到了ACK报文，客户端可以安心关闭了。

总结：主动关闭方最后等待2MSL后关闭连接，是为了尽量保证被动方收到了ACK。(依然不能完全保证)