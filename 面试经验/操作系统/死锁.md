# 死锁
* ### 原因
    1. 竞争资源
        + 通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，相似的进程在运行过程中会因争夺资源而陷入僵局。
        + 只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。
    2. 程序推进顺序不当
        + 进程在运行过程中，请求和释放资源的顺序不当，同样会导致死锁。
        + 信号量使用不当也会造成死锁。进程间相互等待对方发来的消息，结果也会造成某些进程间无法继续向前推进。
* ### 必要条件
    1. 互斥条件：资源不能被共享，只能由一个进程使用。
    2. 请求和保持条件：已经得到资源的进程可以再次申请新的资源。
    3. 不剥夺条件：已经分配的资源不能从相应的进程中被强制地剥夺。
    4. 循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。
* ### 处理死锁基本方法:
    1. 预防死锁(破坏除1以外的必要条件，因为无法允许系统资源共享使用)
        + (破坏条件3)当一个以保持了某些不可剥夺资源的进程，请求新的资源时得不到满足，它必须释放已经保持的所有资源，待以后需要时再重新申请。这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。
        + (破坏条件2)采用预先静态分配方法， 即进程在运行前一次申请完他所需要的全部资源，在他的资源未满足前，不把它投入运行。一旦运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。
        这种方式实现简单，但缺点也显而易见，系统资源被严重浪费，其中有些资源可能仅在运行初期或末期才使用，甚至根本不使用。而且还会导致“饥饿”现象，当由于个别资源长期被个别资源占用时，将只是等待该资源的进程迟迟不能开始运行。
        + (破坏条件4)采用顺序资源分配法。首先给系统中的资源编号，规定每个进程，必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源，则该进程在以后的资源申请中，只能申请编号比之前大的资源。
    2. 避免死锁(银行家算法)
        + 把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。
        + 当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足他的最大需求量，则按当前的申请量分配资源，否则就推迟分配。
        + 当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。
        + 若超过，则拒绝分配资源，若没有超过则在测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。
    3. 检测死锁(资源分配图)
        + 用圆圈代表一个进程，用方框代表一类资源。
        + 从进程到资源的有向边叫请求边，表示该进程请申请一个单位的该类资源；从资源到进程的边叫做分配边，表示该类资源已经有一个资源被分配到了该进程。
        + 可以通过将资源分配图简化的方法来检测系统状态S是否为死锁状态。
        + 资源分配图简化方法：
            1. 在资源分配图中，找出既不阻塞又不是孤点的进程Pi，Pi存在有向边，且Pi申请的所有资源均小于系统中已有的空闲资源数量。这可以消去Pi的所有请求边和分配边，使之成为孤立的节点。
            2. 进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。然后继续用1的方式消除。
            3. S为死锁的条件是当且仅当S状态的资源分配图是不可简化的，该条件为死锁定理。
    4. 解除死锁
        + 剥夺资源：挂起某些思索进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源时，而处于资源匮乏的状态。
        + 撤销进程：强制撤销一个或一部分进程并剥夺这些进程的资源。撤销的原则可以按进程的优先级和撤销进程代价的高低进行。
        + 进程回退(一般不用，系统开销极大)：让一个或多个进程回退到足以回避死锁的地步，进程回退时资源释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。