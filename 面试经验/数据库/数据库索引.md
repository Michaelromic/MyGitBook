数据库索引
MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。
通常使用最多的是BTree索引。

https://zhuanlan.zhihu.com/p/27700617

* ### 平衡二叉树
    + 非叶子节点最多拥有两个子节点，叶子节点没有子节点
    + 左孩子的值 < 当前节点的值 < 右孩子的值
    + 数据的左右两边的节点层级相差不会大于1，避免树形结构由于删除增加变成线性链表影响查询效率，保证数据平衡的情况下查找数据的速度近于二分法查找
    + 没有值相等重复的节点

* ### B树(B-tree，就读做B树，并不是B减树)
和 平衡二叉树 稍有不同的是，B树属于多叉树，又名"平衡多路查找树"(查找路径不只两个)。
* 规则：
    1. 排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则
    2. 子节点数：非叶节点的子节点数>1，且<=M ，且M>=2 (注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉)
    3. 关键字数：枝节点的关键字数量大于等于ceil(M/2)-1个且小于等于M-1个（ceil是向上取整，关键字数=指针数-1，指针数对应子节点数，最大是M，所以关键字数最大是M-1)
    4. 所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null

* 为什么非根非叶节点的关键字数量大于等于 ceil(m/2)-1？
因为关键字数小于 ceil(m/2)-1 的非根非叶节点在平衡过程中势必可以合并消除。

假设存在一个节点A，它的关键字数小于 ceil(m/2)-1
情况一：其邻近兄弟节点C关键字数大于 ceil(m/2)-1，则可以向C借一个关键字转化为他俩的新父节点，原父节点下移到A节点的最右边。
例如，这是一个5阶平衡查找树，A节点只有一个关键字，CDE节点有3个关键字(大于2)，那么可以转换。
    B               C
   / \      =>     / \
  A  CDE          AB DE

情况二：其邻近兄弟节点C关键字数等于 ceil(m/2)-1，此时不能再向兄弟借。则将父节点中位于兄弟俩中间的数下移到A节点的最右边，并且与兄弟节点合并。
例如：
    B E                E
   / \ \      =>      / \
  A  CD FG          ABCD  FG

情况三：其邻近兄弟节点C关键字数小于 ceil(m/2)-1，则可以合并或消除节点。
例如：
    B D                D
   / \ \      =>      / \
  A   C EF          ABC  EF


* m阶B树的定义如下：
    1. 根节点至少包括两个孩子
    2. 树中每个节点最多含有m个孩子（m>=2）
    3. 除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子（ceil()为向上取整）
    4. 所有叶子节点都位于同一层
    5. 每个非叶节点包括n个关键字信息，其中ceil(m/2)-1<=n<=m-1

* 举例：
           M
      /         \
     D G        Q T
    / / \      / \ \
   AC EF HKL  NP RS WXYZ
    + M节点有1个关键字，2个子节点。子节点1的所有关键字都小于M，子节点2的所有关键字都大于M。
    + DG节点有2个关键字，就有3个子节点。子节点1的所有关键字都小于D，子节点2的所有关键字都大于D且小于G，子节点3的所有关键字都大于G。

* B树的查询流程：（例如从上面的B树中找到E字母）
    1. 获取根节点的关键字进行比较，当前根节点关键字为M，E<M，所以在左子节点中找。
    2. 左子节点关键字是DG，因为 D<E<G，所以直接找到D和G中间的节点。
    3. 拿到关键字E和F，找到了E，于是返回关键字和指针信息(指向数据表位置的指针)

* B树的插入节点流程
定义一个5阶树（平衡5路查找树，即m=5），现在我们要把3、8、31、11、23、29、50、28 这些数字构建出一个5阶树出来。
遵循规则：
    1. 节点拆分规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须<=5-1（这里关键字数>4就要进行节点拆分），同时关键字数 >= cell(5/2)-1 = 2
    2. 排序规则：满足节点本身比左边节点大，比右边节点小的排序规则

构建步骤：
    1. 节点的关键字数要小于等于4，所以先插入 3、8、31、11
        3 8 11 31
    2. 插入23，因为节点的关键字数要大于等于2，所以拆开成3个节点，再然后插入29 和 50
            11                      11
          /    \        =>       /      \
        3 8   23 31            3 8   23 29 31 50
    3. 再插入28，右子节点关键字数又达到5个，需要拆开
            11    29
          /     /    \
        3 8  23 28  31 50

* B树节点的删除
遵循规则：
    1. 节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于 ceil(5/2)-1 = 2(关键字数<2就要进行节点合并)。
    2. 满足节点本身比左边节点大，比右边节点小的排序规则
    3. 关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放

例如，删除上面5阶树的关键字28，该节点只剩下23。
    其左兄弟节点只有2个关键字，那么可以和 左兄弟节点+与左兄弟节点的父节点合并
    其右兄弟节点也只有2个关键字，那么也可以和 有兄弟节点+与右兄弟节点的父节点合并
            29                       11
         /      \        =>       /      \
    3 8 11 23  31 50            3 8   23 29 31 50

* B树的特点
    + B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了
    + 特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围
    + 把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度


* ### B+树
B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找，查找的效率要比B树更高、更稳定。
* 规则
    1. B+跟B树不同的是：B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加
    2. B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样
    3. B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针
    4. 非叶子节点的子节点数=关键字数 (mysql的B+树采用的是这种方式，实际上有另外一种实现，就是 非叶节点的关键字数=子节点数-1)

* 特点
    1. B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快
    2. B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定
    3. B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高
    4. B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描

* B树相对于B+树的优点:
如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。



* ### B-/+Tree索引的性能分析
    + 磁盘预读
    首先，由于磁盘读写慢，因此每次都会预读。
    这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。
    预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。

    + B-/+Tree索引的优势
        + 假设B树高度为h，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。
        + 每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。
        + B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。
        + 而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。

---

# MySQL索引实现

* ### MyISAM索引实现
MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。
MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。

* ### InnoDB索引实现
InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。
区别：
    1. InnoDB的数据文件本身就是索引文件。
    MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。
    而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录(包括其他非索引列的数据)。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。
    
    这种索引叫做 "聚集索引"。

    因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有）。
    如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

    假设某张表 table_user有3列，uid、name、age，索引列是uid。
    在MyISAM中，叶节点的data域记录的是 数据记录的地址，然后依据地址去找到该行其他列的数据。
    而在InnoDB中，假设uid是主键，那么叶节点的data域记录的是 name和age。

    2. InnoDB的辅助索引data域存储相应记录主键的值而不是地址。即InnoDB的所有辅助索引都引用主键作为data域。
    假如现在索引列是age，那么InnoDB的叶节点存的是其对应的主键uid的值。
    因此，辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。


* ### 最左前缀原理与相关优化 (B+树)
    假设有一个组合索引 (uid,name,age)
    
    1. 只用uid做条件，或者用 uid+name做条件，也是可以命中索引的，但是只能用到一部分索引。
    假如用 uid+age做条件，和只用uid没有区别。
    
    2. 匹配某列的前缀字符串也可以命中索引(uid+name的索引)。
    例如 uid = 1001 and name like '%zhang'
    
    3. 范围查询可以用到索引，但必须是最左前缀。
    如果指定uid和name,加上age的范围，则可以命中完整的索引。(uid+name+age)。
    例如 uid < 1010 and name = 'zhangsan'，仅仅可以命中 uid索引。索引最多用于一个范围列。

    注意：between不一定是范围匹配，如果作用在这里的uid上，则是精确匹配，相当于 in。

    4. 如果查询条件中有函数或者表达式，则无法命中索引。
    例如： uid + 1 = 1001

    5. 可以加前缀索引
    假如现在要查两个字段 firstname + lastname，但是2个字段加起来很长，我们可以对lastname加前缀索引。
    ALTER TABLE employees.employees ADD INDEX `first_name_last_name4` (first_name, last_name(4));
    执行之后，可以通过 show profiles;来查看运行的性能(时间)。

* ### InnoDB的主键选择与插入优化
InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。
这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置。
如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。

* 在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。
    + 如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置。这样就会形成一个紧凑的索引结构，近似顺序填满。
    + 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置。
    此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销。
    同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。

因此，只要可以，尽量在InnoDB上采用自增字段做主键。