# MVCC (在事务操作的数据快照上进行，并不修改实际的数据，提交时才修改)
> 全称是Multi-Version Concurrent Control，即多版本并发控制。
> 在MVCC协议下，每个读操作会看到一个一致性的snapshot，并且可以实现非阻塞的读。
> MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。
>
> 例如：a=1，A事务中更新了a=2，但还没有提交，此时A事务读到的A是2，B事务读到的A是1。

* ### MySQL的innodb引擎是如何实现MVCC的
innodb会为每一行添加两个字段，分别表示该行创建的版本和删除的版本，填入的是事务的版本号，这个版本号随着事务的创建不断递增。
在repeated read的隔离级别（事务的隔离级别请看这篇文章）下，具体各种数据库操作的实现：
    * select：满足以下两个条件innodb会返回该行数据：
        + 该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。
        + 该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。
    * insert：将新插入的行的创建版本号设置为当前系统的版本号。
    * delete：将要删除的行的删除版本号设置为当前系统的版本号。
    * update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。
    
    其中，写操作（insert、delete和update）执行时，需要将系统版本号递增。
    
    ​由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。
    
    通过MVCC很好的实现了事务的隔离性，可以达到repeated read级别，要实现serializable还必须加锁。

* ### 隔离性
在事务并发操作时，可能出现的问题有：
    + 脏读：还是上面的例子，假如B事务读到的是A事务还没有提交的2，然后A又提交失败了，B读到的就是脏数据。
    + 不可重复读：在同一个事务中，对于同一份数据读取到的结果不一致。假如B事务在A提交前读到的是1，A提交后读到的是2，就是不可重复读。
    + 幻读：在同一个事务中，同一个查询多次返回的结果不一致。假如A添加了一条记录 b=3，B在A提交前只读到一行数据，在A提交后读到两行数据，这个就是幻读。

事务的隔离级别从低到高有：
    + Read Uncommitted(读取未提交)：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。
    + Read Committed(读取已提交)：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。
    + Repeated Read（可重读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。但幻读仍有可能发生。
    + Serialization(可串行化)：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。