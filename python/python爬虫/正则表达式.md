** r表示不转义，比如 r'\t' 输出就是 \t，而不是制表符 **

# 正则表达式
import re
* \ 转义
* ^ 主串开头
* $ 主串结尾
* \* 前面子表达式匹配0次或多次
* \+ 前面子表达式匹配1次或多次
* ? 前面子表达式匹配0次或1次
* {n,m} 前面子表达式匹配至少n次, 最多m次，(可以缺省，表示无限制，如: {1,} 或 {,5})
* . 匹配除 \n 以外的任意字符
* [xyz] 字符集合，匹配任意集合里的字符，可以是x，也可以是y，也可以是z，例如：xx, xy, xz, yy
* \[^xyz] 排除集合里的字符，其他字符都可以
* [a-z] 匹配所有的小写字符，例如：a, b, ac, bcd
* \[^0-9] 匹配排除所有的数字，例如： abc
* \s 是空格
* (pattern) 小括号表示只返回小括号内的内容，其他内容都只是作限定条件，例如：ab(ce)e只返回cd **
* \w 匹配非特殊字符，即a-z、A-Z、0-9、_、汉字 **

** 注意：如果有小括号()，则只返回小括号内的内容，其他内容都只是作限定条件 **

---
### 贪婪模式 和 非贪婪模式
？该字符紧跟在任何一个其他限制符(*,+,?,{n},{n,},{n,m})后面时，匹配模式是非贪婪的。
* 非贪婪模式尽可能少的匹配所搜索的字符串
* 默认的贪婪模式则尽可能多的匹配所搜索的字符串

例如：
字符串 abc#aaa#
a.*?# 会匹配出 ['abc#', 'aaa#']
a.*# 会匹配出 ['abc#aaa#']

** 注意：非贪婪模式 ? 是要紧跟着前面其他限制符的，不能放在小括号外，例如 (.*)? 是无效的，只能写作 (.*?) **

---
### sub替换模式
import re
re.sub(正则式, 替换后的内容, 原字符串)
例如：
re.sub('[a-z]+', '小写字母', '123adcs322')
输出的是字符串：'123小写字母322'

---
# 正向肯定预查 和 反向肯定预查
** 注意：预查不消耗字符，所以本身不会被替换掉 **
* 正向肯定预查(?=pattern)，在任何匹配pattern的字符串开始处匹配查找字符串。
* 反向肯定预查(?<=pattern)，与正向肯定预查类拟，只是方向相反。

```
(?<=pattern) 表示前面限定是这个pattern, 这里括号的内容是不取出来的
(?=pattern) 表示后面限定是这个pattern, 这里括号的内容是不取出来的
```

re.findall('[a-z|123]+', '###123adcs322###')
输出 ['123adcs322']
re.findall('(?<=a)[a-z|123]+(?=22)', '###123adcs322###')
输出 ['dcs3']
** 注意：一般小括号是表示只返回小括号里面的内容，这里的 ?<= 和 ?= 分别是匹配前面和后面的内容，但是不返回，还是只返回中间的内容 **

** 特别注意：在sub替换的时候，()是不起作用的 **
```
re.findall('123([a-z]+)322', '###123adcs322###')
输出 ['adcs']
re.sub('123([a-z]+)322', '小写字母', '###123adcs322###')
输出 '###小写字母###'
--
正确的实现方式是，用预查
re.sub('(?<=123)[a-z]+(?=322)', '小写字母', '###123adcs322###')
输出 '###123小写字母322###'
```
总结：
选择的时候，可以前后限定(?<= 和 ?=)，也可以给中间加小括号
替换的时候，只能前后限定


### 正则模块match与compile
pattern = re.compile('>(.*?)<')
pattern.findall(s)

# search就是在字符串中查找，match就是从字符串开始处查找，fullmatch就是查找整个字符串
pattern.search(s)
pattern.match(s)
pattern.fullmatch(s)


### 分组
# 用小括号括起来的作为一个分组，从1开始计算，0组表示全部匹配
m = re.match(r"(\w+) (\w+)", "Isaac Newton, physicist")
m.group(0)
m.group(1)
m.group(1,2) #这里返回一个元组
m.groups() #返回所有分组的元组，在这里和 m.group(1,2)效果一样

# 命名分组
# (?P<name>正则表达式)  #name是一个合法的标识符
m = re.match(r"(?P<first_name>\w+) (?P<last_name>\w+)", "Malcolm Reynolds")
m.group('first_name')
m.group('last_name')